#ifndef _FLOW_H_
#define _FLOW_H_

#pragma once

/* Don't modify this file manually. It is autogenerated by cbindgen. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Sample rate expected by VAD
 */
#define VAD_SAMPLE_RATE 16000

/**
 * Chunk size for VAD processing (512 samples = 32ms at 16kHz)
 */
#define VAD_CHUNK_SIZE 512

/**
 * Opaque handle to the Flow engine
 */
typedef struct FlowHandle FlowHandle;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the Flow engine
 *
 * Returns an opaque handle that must be passed to all other functions.
 *
 * # Arguments
 * - `db_path` - Path to the SQLite database file, or NULL for default location
 *
 * # Returns
 * Opaque handle to the engine, or NULL on failure
 */
struct FlowHandle *flow_init(const char *db_path);

/**
 * Destroy the Flow engine and free resources
 */
void flow_destroy(struct FlowHandle *handle);

/**
 * Start audio recording
 * Returns true on success
 */
bool flow_start_recording(struct FlowHandle *handle);

/**
 * Stop audio recording and get the duration
 *
 * This function extracts audio data and fully releases the microphone device.
 *
 * # Arguments
 * - `handle` - Engine handle
 *
 * # Returns
 * Duration in milliseconds, or 0 on failure
 */
uint64_t flow_stop_recording(struct FlowHandle *handle);

/**
 * Check if currently recording
 */
bool flow_is_recording(struct FlowHandle *handle);

/**
 * Get current audio level (RMS amplitude) from the recording
 * Returns a value between 0.0 and 1.0, or 0.0 if not recording
 */
float flow_get_audio_level(struct FlowHandle *handle);

/**
 * Transcribe the recorded audio and process it
 *
 * # Arguments
 * - `handle` - Engine handle
 * - `app_name` - Name of the current app (for mode selection), or NULL
 *
 * # Returns
 * Processed text (caller must free with flow_free_string), or NULL on failure
 */
char *flow_transcribe(struct FlowHandle *handle, const char *app_name);

/**
 * Retry the last transcription using cached audio
 * Returns processed text (caller must free with flow_free_string), or null on failure
 */
char *flow_retry_last_transcription(struct FlowHandle *handle, const char *app_name);

/**
 * Add a voice shortcut
 *
 * # Arguments
 * - `handle` - Engine handle
 * - `trigger` - Trigger phrase
 * - `replacement` - Replacement text
 *
 * # Returns
 * true on success
 */
bool flow_add_shortcut(struct FlowHandle *handle, const char *trigger, const char *replacement);

/**
 * Remove a voice shortcut
 * Returns true on success
 */
bool flow_remove_shortcut(struct FlowHandle *handle, const char *trigger);

/**
 * Get the number of shortcuts
 */
size_t flow_shortcut_count(struct FlowHandle *handle);

/**
 * Set the writing mode for an app
 *
 * # Arguments
 * - `handle` - Engine handle
 * - `app_name` - Name of the app
 * - `mode` - Writing mode (0=Formal, 1=Casual, 2=VeryCasual, 3=Excited)
 *
 * # Returns
 * true on success
 */
bool flow_set_app_mode(struct FlowHandle *handle, const char *app_name, uint8_t mode);

/**
 * Get the writing mode for an app
 * Returns: 0 = Formal, 1 = Casual, 2 = VeryCasual, 3 = Excited
 */
uint8_t flow_get_app_mode(struct FlowHandle *handle, const char *app_name);

/**
 * Report a user edit to learn from
 *
 * # Arguments
 * - `handle` - Engine handle
 * - `original` - Original transcribed text
 * - `edited` - Text after user edits
 *
 * # Returns
 * true on success
 */
bool flow_learn_from_edit(struct FlowHandle *handle, const char *original, const char *edited);

/**
 * Get the number of learned corrections
 */
size_t flow_correction_count(struct FlowHandle *handle);

/**
 * Get all corrections as JSON
 * Returns JSON array: [{"id": "...", "original": "...", "corrected": "...", "occurrences": N, "confidence": N.N}, ...]
 * Caller must free the returned string with flow_free_string
 */
char *flow_get_corrections_json(struct FlowHandle *handle);

/**
 * Delete a correction by ID
 * Returns true if the correction was deleted, false if not found or on error
 */
bool flow_delete_correction(struct FlowHandle *handle, const char *id);

/**
 * Delete all corrections
 * Returns the number of corrections deleted
 */
size_t flow_delete_all_corrections(struct FlowHandle *handle);

/**
 * Validate corrections using AI (async, returns JSON)
 * Input: JSON array of {"original": "...", "corrected": "..."} pairs
 * Output: JSON array of {"original": "...", "corrected": "...", "valid": bool, "reason": "..."}
 * Caller must free the returned string with flow_free_string
 */
char *flow_validate_corrections(struct FlowHandle *_handle, const char *corrections_json);

/**
 * Get total transcription time in minutes
 */
uint64_t flow_total_transcription_minutes(struct FlowHandle *handle);

/**
 * Get total transcription count
 */
uint64_t flow_transcription_count(struct FlowHandle *handle);

/**
 * Free a string returned by flow functions
 */
void flow_free_string(char *s);

/**
 * Check if the transcription provider is configured
 */
bool flow_is_configured(struct FlowHandle *handle);

/**
 * Set the currently active app (call from Swift when app switches)
 * Returns the suggested writing mode for the app
 */
uint8_t flow_set_active_app(struct FlowHandle *handle,
                            const char *app_name,
                            const char *bundle_id,
                            const char *window_title);

/**
 * Get the current app's category
 * Returns: 0=Email, 1=Slack, 2=Code, 3=Documents, 4=Social, 5=Browser, 6=Terminal, 7=Unknown
 */
uint8_t flow_get_app_category(struct FlowHandle *handle);

/**
 * Get current app name (caller must free with flow_free_string)
 */
char *flow_get_current_app(struct FlowHandle *handle);

/**
 * Report edited text to learn user's style for current app
 */
bool flow_learn_style(struct FlowHandle *handle, const char *edited_text);

/**
 * Get suggested mode based on learned style for current app
 * Returns: 0=Formal, 1=Casual, 2=VeryCasual, 3=Excited, 255=no suggestion
 */
uint8_t flow_get_style_suggestion(struct FlowHandle *handle);

/**
 * Get user stats as JSON (caller must free with flow_free_string)
 */
char *flow_get_stats_json(struct FlowHandle *handle);

/**
 * Get recent transcriptions as JSON (caller must free with flow_free_string)
 */
char *flow_get_recent_transcriptions_json(struct FlowHandle *handle, size_t limit);

/**
 * Get the last error message (caller must free with flow_free_string)
 */
char *flow_get_last_error(struct FlowHandle *handle);

/**
 * Switch completion provider (loads API key from database)
 * provider: 0 = OpenAI, 1 = Gemini, 2 = OpenRouter
 * Returns true if provider was switched successfully
 */
bool flow_switch_completion_provider(struct FlowHandle *handle, uint8_t provider);

/**
 * Set completion provider with API key (saves both)
 * provider: 0 = OpenAI, 1 = Gemini, 2 = OpenRouter
 * api_key: The API key for the provider
 */
bool flow_set_completion_provider(struct FlowHandle *handle, uint8_t provider, const char *api_key);

/**
 * Get the current completion provider name
 * Returns: 0 = OpenAI, 1 = Gemini, 2 = OpenRouter, 255 = Unknown
 */
uint8_t flow_get_completion_provider(struct FlowHandle *handle);

/**
 * Get API key for a specific provider in masked form
 * provider: 0 = OpenAI, 1 = Gemini, 2 = OpenRouter
 * Returns null if no key is set, or a masked version like "sk-••••••••"
 * Caller must free the returned string with flow_free_string
 */
char *flow_get_api_key(struct FlowHandle *handle, uint8_t provider);

/**
 * Set transcription mode (local or remote)
 * use_local: true for local Whisper, false for cloud provider
 * whisper_model: Model selection (only used when use_local = true)
 *   0 = Turbo (~15MB) - quantized, ultra-fast, lowest memory
 *   1 = Fast (~39MB) - fast, lower accuracy
 *   2 = Balanced (~142MB) - good speed/accuracy balance
 *   3 = Quality (~400MB) - great accuracy, still fast [recommended]
 *   4 = Best (~750MB) - best quality available
 * Returns true on success, false on failure
 */
bool flow_set_transcription_mode(struct FlowHandle *handle, bool use_local, uint8_t whisper_model);

/**
 * Get current transcription mode settings
 * Returns use_local flag and whisper_model (0-4) via out parameters
 * Returns false on database error, true on success
 */
bool flow_get_transcription_mode(struct FlowHandle *handle,
                                 bool *out_use_local,
                                 uint8_t *out_whisper_model);

/**
 * Check if a Whisper model is currently being downloaded/initialized
 * Returns true if model download/initialization is in progress
 */
bool flow_is_model_loading(struct FlowHandle *handle);

/**
 * Legacy function - prefer flow_set_transcription_mode
 * Enable local Whisper transcription with Metal + Accelerate acceleration
 * model: 0=Turbo, 1=Fast, 2=Balanced, 3=Quality, 4=Best
 * Returns true on success, false on failure
 */
bool flow_enable_local_whisper(struct FlowHandle *handle, uint8_t model);

/**
 * Get available Whisper models as JSON (caller must free with flow_free_string)
 * Returns JSON array with model info including id, name, description, size, and flags
 */
char *flow_get_whisper_models_json(void);

/**
 * Get all shortcuts as JSON (caller must free with flow_free_string)
 */
char *flow_get_shortcuts_json(struct FlowHandle *handle);

/**
 * Get active contact name from Messages.app window
 * Returns C string with contact name, or null if not available
 * Caller must free with flow_free_string
 */
char *flow_get_active_messages_contact(struct FlowHandle *handle);

/**
 * Classify a contact given name and organization
 * Returns JSON string with category
 * Caller must free with flow_free_string
 */
char *flow_classify_contact(struct FlowHandle *handle, const char *name, const char *organization);

/**
 * Classify multiple contacts from JSON array
 * Input format: [{"name": "...", "organization": "..."}]
 * Output format: {"ContactName": "category", ...}
 * Caller must free with flow_free_string
 */
char *flow_classify_contacts_batch(struct FlowHandle *handle, const char *contacts_json);

/**
 * Record interaction with a contact (updates frequency)
 */
void flow_record_contact_interaction(struct FlowHandle *handle, const char *name);

/**
 * Get frequent contacts as JSON array
 * Returns: [{"name": "...", "category": "...", "frequency": N}, ...]
 * Caller must free with flow_free_string
 */
char *flow_get_frequent_contacts(struct FlowHandle *handle, uint32_t limit);

/**
 * Get suggested writing mode for a contact category
 * Returns: 0=Formal, 1=Casual, 2=VeryCasual, 3=Excited
 */
uint32_t flow_get_writing_mode_for_category(struct FlowHandle *handle, uint32_t category);

/**
 * Set cloud transcription provider (saves preference)
 * provider: 0 = OpenAI, 1 = Auto (default)
 * Returns true on success
 */
bool flow_set_cloud_transcription_provider(struct FlowHandle *handle, uint8_t provider);

/**
 * Get the current cloud transcription provider
 * Returns: 0 = OpenAI, 1 = Auto (default)
 */
uint8_t flow_get_cloud_transcription_provider(struct FlowHandle *handle);

/**
 * Align original and edited text, extract correction candidates
 * Returns JSON with alignment result (caller must free with flow_free_string)
 * JSON format:
 * {
 *   "steps": [...],
 *   "word_edit_vector": "MMSMM",
 *   "punct_edit_vector": "ZZZZ",
 *   "corrections": [["original", "corrected"], ...]
 * }
 */
char *flow_align_and_extract_corrections(const char *original, const char *edited);

/**
 * Get dictionary context for ASR prompting
 * Returns JSON array of high-confidence learned words (caller must free with flow_free_string)
 */
char *flow_get_dictionary_context(struct FlowHandle *handle, uint32_t limit);

/**
 * Save edit analytics for tracking alignment patterns
 * Returns true on success
 */
bool flow_save_edit_analytics(struct FlowHandle *handle,
                              const char *word_edit_vector,
                              const char *punct_edit_vector,
                              const char *original_text,
                              const char *edited_text);

/**
 * Save a learned words session for undo functionality
 * words_json: JSON array of strings ["word1", "word2", ...]
 * Returns session ID (or -1 on error)
 */
int64_t flow_save_learned_words_session(struct FlowHandle *handle, const char *words_json);

/**
 * Undo the most recent learned words session
 * Removes the corrections and marks session as used
 * Returns true if undo was performed
 */
bool flow_undo_learned_words(struct FlowHandle *handle);

/**
 * Get the most recent undoable learned words as JSON
 * Returns JSON array of strings (caller must free with flow_free_string)
 * Returns null if no undoable session exists
 */
char *flow_get_undoable_learned_words(struct FlowHandle *handle);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* _FLOW_H_ */
